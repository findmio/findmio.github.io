[{"content":"题目 实现一个 LazyMan，可以按照以下方式调用:\nLazyMan(\u0026#39;Tony\u0026#39;); // Hi I am Tony  LazyMan(\u0026#39;Tony\u0026#39;).sleep(10).eat(\u0026#39;lunch\u0026#39;); // Hi I am Tony // 等待了10秒... // I am eating lunch  LazyMan(\u0026#39;Tony\u0026#39;).eat(\u0026#39;lunch\u0026#39;).sleep(10).eat(\u0026#39;dinner\u0026#39;); // Hi I am Tony // I am eating lunch // 等待了10秒... // I am eating diner  LazyMan(\u0026#39;Tony\u0026#39;) .eat(\u0026#39;lunch\u0026#39;) .eat(\u0026#39;dinner\u0026#39;) .sleepFirst(5) .sleep(10) .eat(\u0026#39;junk food\u0026#39;); // Hi I am Tony // 等待了5秒... // I am eating lunch // I am eating dinner // 等待了10秒... // I am eating junk food 思路 总共需要实现三个函数：一个同步的 eat，两个异步的 sleep、sleepFirst。\n目前可公开情报：\n 这些函数需要能够 链式调用，所以在执行完毕，要返回这个对象 异步函数会延迟之后的函数执行 sleepFirst 需要先执行  为了实现异步函数阻塞之后的函数执行，我们先用一个队列来储存函数的调用，然后依序执行。\nclass Man { constructor(name) { this.queue = []; console.log(`Hi I am ${name}`); // 创建一个微任务，在同步代码执行完后开始处理任务队列  queueMicrotask(() =\u0026gt; { this.next(); }) } eat(food) { this.queue.push(() =\u0026gt; { console.log(`I am eating ${food}`); this.next(); }); // 返回 this，实现链式调用  return this; } sleep(time) { this.queue.push(() =\u0026gt; { setTimeout(() =\u0026gt; { console.log(`等待了${time}秒...`); // 在定时结束后开始执行下一个任务  this.next(); }, time * 1000); }); return this; } sleepFirst(time) { // 插入到队列的最前面  this.queue.unshift(() =\u0026gt; { setTimeout(() =\u0026gt; { console.log(`等待了${time}秒...`); this.next(); }, time * 1000); }); return this; } next() { this.queue.shift()?.(); } } function LazyMan(name) { return new Man(name); } ","permalink":"https://findmio.github.io/post/interview/lazyman/","summary":"题目 实现一个 LazyMan，可以按照以下方式调用:\nLazyMan(\u0026#39;Tony\u0026#39;); // Hi I am Tony  LazyMan(\u0026#39;Tony\u0026#39;).sleep(10).eat(\u0026#39;lunch\u0026#39;); // Hi I am Tony // 等待了10秒... // I am eating lunch  LazyMan(\u0026#39;Tony\u0026#39;).eat(\u0026#39;lunch\u0026#39;).sleep(10).eat(\u0026#39;dinner\u0026#39;); // Hi I am Tony // I am eating lunch // 等待了10秒... // I am eating diner  LazyMan(\u0026#39;Tony\u0026#39;) .eat(\u0026#39;lunch\u0026#39;) .eat(\u0026#39;dinner\u0026#39;) .sleepFirst(5) .sleep(10) .eat(\u0026#39;junk food\u0026#39;); // Hi I am Tony // 等待了5秒... // I am eating lunch // I am eating dinner // 等待了10秒... // I am eating junk food 思路 总共需要实现三个函数：一个同步的 eat，两个异步的 sleep、sleepFirst。","title":"编程题：实现一个 LazyMan"},{"content":"生命不息，敲码不止\n","permalink":"https://findmio.github.io/about/","summary":"生命不息，敲码不止","title":"关于我"},{"content":"题目 地址：https://leetcode-cn.com/problems/fibonacci-number/\n解题 斐波那契数列的特点是由后两个数字相加得出下一个数字， 首先能想到的就是用递归来解决。\n递归的出口是\nF(0) = 0，F(1) = 1\n找到出口之后就很简单了，三下五除二就写出来：\nvar fib = function (n) { if (n \u0026lt;= 1) { return n; } function add(num) { if (num === 1 || num === 0) { return num; } else { return add(num - 1) + add(num - 2); } } return add(n); }; 愉快的提交之后，\n嚯，击败了 14% 的提交。\n优化 由于盲目的使用递归，造成了大量的重复操作，时间复杂度是 O(2^n)，指数级爆炸。\n自顶而下 为了解决这些重复的操作，使用 memoization 的思想来对已计算的数据进行缓存。\n下面来用 数组 实现一下：\nvar fib = function (n) { if (n \u0026lt;= 1) { return n; } let fibArr = [0, 1]; function add(num) { if (fibArr[num] !== undefined) { return fibArr[num]; } else { fibArr[num] = add(num - 1) + add(num - 2); return fibArr[num]; } } return add(n); }; 和之前的简单递归代码相似，不过对未缓存的斐波那契数列进行缓存，再次获取这个数列的时候就从数组中直接取，省去了大量的重复递归操作。\n简单的修改之后，再次提交，击败了 92% 的提交，还算可以。\n自底向上 上面的解法是自顶而下的求值，还有一种是自底向上的解法。\n先计算出需要求的最大值，然后从小到大进行计算。\nvar fib = function (n) { if (n \u0026lt;= 1) { return n; } let fibArr = [0, 1]; for (let index = 2; index \u0026lt;= n; index++) { fibArr[index] = fibArr[index - 1] + fibArr[index - 2]; } return fibArr[n]; }; 不需要使用到递归，或许更好理解。\n","permalink":"https://findmio.github.io/post/algorithm/209.-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/","summary":"题目 地址：https://leetcode-cn.com/problems/fibonacci-number/\n解题 斐波那契数列的特点是由后两个数字相加得出下一个数字， 首先能想到的就是用递归来解决。\n递归的出口是\nF(0) = 0，F(1) = 1\n找到出口之后就很简单了，三下五除二就写出来：\nvar fib = function (n) { if (n \u0026lt;= 1) { return n; } function add(num) { if (num === 1 || num === 0) { return num; } else { return add(num - 1) + add(num - 2); } } return add(n); }; 愉快的提交之后，\n嚯，击败了 14% 的提交。\n优化 由于盲目的使用递归，造成了大量的重复操作，时间复杂度是 O(2^n)，指数级爆炸。\n自顶而下 为了解决这些重复的操作，使用 memoization 的思想来对已计算的数据进行缓存。\n下面来用 数组 实现一下：","title":"209. 斐波那契数"}]