[{"content":"题目 地址：https://leetcode.cn/problems/two-sum/\n思路 通过 Map 把数组的每一项进行缓存 （key 为数组中的项，value 为索引），然后再对数组进行遍历，并计算是否存在 key 相加等于目标值\n遍历数组，判断差值是否存在 Map 中 如果存在，返回对应的索引 如果不存在，将这一项添加到 Map 中 数组遍历结束，返回一个兜底的数组 [-1, -1] /** * @param {number[]} nums * @param {number} target * @return {number[]} */ var twoSum = function (nums, target) { const map = new Map(); for (let i = 0; i \u0026lt; nums.length; i++) { const item = nums[i]; const different = target - item; if (map.get(different) !== undefined) { return [map.get(different), i]; } else { map.set(item, i); } } return [-1, -1]; }; ","permalink":"https://findmio.github.io/post/leetcode/1_%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","summary":"题目 地址：https://leetcode.cn/problems/two-sum/\n思路 通过 Map 把数组的每一项进行缓存 （key 为数组中的项，value 为索引），然后再对数组进行遍历，并计算是否存在 key 相加等于目标值\n遍历数组，判断差值是否存在 Map 中 如果存在，返回对应的索引 如果不存在，将这一项添加到 Map 中 数组遍历结束，返回一个兜底的数组 [-1, -1] /** * @param {number[]} nums * @param {number} target * @return {number[]} */ var twoSum = function (nums, target) { const map = new Map(); for (let i = 0; i \u0026lt; nums.length; i++) { const item = nums[i]; const different = target - item; if (map.get(different) !== undefined) { return [map.","title":"1_两数之和"},{"content":"树 树 是数据结构中很常见的一种数据结构，是一种分层数据的抽象模型。\n树形结构存在下列特征：\n除根节点外，每个节点都有一个父节点 每个节点有零个或者多个子节点 二叉树 二叉树 是树形结构中的一种。 二叉树中的节点最多只能有两个子节点：一个是左节点，一个是右节点。\n二叉搜索树（BST）是二叉树的一种，但是只允许你在左节点存储（比父节点）小的值， 在右节点存储（比父节点）大的值。\n实现一个二叉搜索树\n构造一个节点的类用来存储节点值和左右节点 构造一个二叉搜索树的类，它有一个根节点 实现插入节点的方法（insert）\n根据插入的值创建一个节点 判断是否存在根节点 不存在根节点：直接将根节点指向此节点 存在根节点：将根节点和此节点传入 insertNode 方法去处理插入的位置 实现判断插入节点位置的方法（insertNode）。第一个参数为父节点，第二个参数为子节点\n判断子节点要插入到父节点的左侧还是右侧：比父节点小的插入到父节点左侧，比父节点大的插入到父节点右侧 找到子节点要插入到父节点的位置，判断该位置是否已存在 如果被插入的位置已存在的，则递归调用 insertNode 方法，将父节点替换为被插入位置的节点 如果被插入的位置不存在的，直接将子节点插入到父节点上 class Node { // {1} constructor(value) { this.val = value; // 节点值 this.left = null; // 左节点 this.right = null; // 右节点 } } class BinarySearchTree { // {2} constructor() { this.root = null; // 根节点 } insert(value) { const node = new Node(value); // {3} if (this.root === null) { // {4} this.root = node; // {5} } else { this.insertNode(this.root, node); // {6} } } insertNode(root, node) { if (node.val \u0026gt; root.val) { // {7} if (root.right !== null) { // {8} this.insertNode(root.right, node); // {9} } else { root.right = node; // {10} } } else { if (root.left !== null) { // {8} this.insertNode(root.left, node); // {9} } else { root.left = node; // {10} } } } } ","permalink":"https://findmio.github.io/post/tree/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/","summary":"树 树 是数据结构中很常见的一种数据结构，是一种分层数据的抽象模型。\n树形结构存在下列特征：\n除根节点外，每个节点都有一个父节点 每个节点有零个或者多个子节点 二叉树 二叉树 是树形结构中的一种。 二叉树中的节点最多只能有两个子节点：一个是左节点，一个是右节点。\n二叉搜索树（BST）是二叉树的一种，但是只允许你在左节点存储（比父节点）小的值， 在右节点存储（比父节点）大的值。\n实现一个二叉搜索树\n构造一个节点的类用来存储节点值和左右节点 构造一个二叉搜索树的类，它有一个根节点 实现插入节点的方法（insert）\n根据插入的值创建一个节点 判断是否存在根节点 不存在根节点：直接将根节点指向此节点 存在根节点：将根节点和此节点传入 insertNode 方法去处理插入的位置 实现判断插入节点位置的方法（insertNode）。第一个参数为父节点，第二个参数为子节点\n判断子节点要插入到父节点的左侧还是右侧：比父节点小的插入到父节点左侧，比父节点大的插入到父节点右侧 找到子节点要插入到父节点的位置，判断该位置是否已存在 如果被插入的位置已存在的，则递归调用 insertNode 方法，将父节点替换为被插入位置的节点 如果被插入的位置不存在的，直接将子节点插入到父节点上 class Node { // {1} constructor(value) { this.val = value; // 节点值 this.left = null; // 左节点 this.right = null; // 右节点 } } class BinarySearchTree { // {2} constructor() { this.root = null; // 根节点 } insert(value) { const node = new Node(value); // {3} if (this.","title":"树和二叉树"},{"content":"题目 实现一个 LazyMan，可以按照以下方式调用:\nLazyMan(\u0026#39;Tony\u0026#39;); // Hi I am Tony LazyMan(\u0026#39;Tony\u0026#39;).sleep(10).eat(\u0026#39;lunch\u0026#39;); // Hi I am Tony // 等待了10秒... // I am eating lunch LazyMan(\u0026#39;Tony\u0026#39;).eat(\u0026#39;lunch\u0026#39;).sleep(10).eat(\u0026#39;dinner\u0026#39;); // Hi I am Tony // I am eating lunch // 等待了10秒... // I am eating diner LazyMan(\u0026#39;Tony\u0026#39;) .eat(\u0026#39;lunch\u0026#39;) .eat(\u0026#39;dinner\u0026#39;) .sleepFirst(5) .sleep(10) .eat(\u0026#39;junk food\u0026#39;); // Hi I am Tony // 等待了5秒... // I am eating lunch // I am eating dinner // 等待了10秒... // I am eating junk food 思路 总共需要实现三个函数：一个同步的 eat，两个异步的 sleep、sleepFirst。\n目前可公开情报：\n这些函数需要能够 链式调用，所以在执行完毕，要返回这个对象 异步函数会延迟之后的函数执行 sleepFirst 需要先执行 为了实现异步函数阻塞之后的函数执行，我们先用一个队列来储存函数的调用，然后依序执行。\nclass Man { constructor(name) { this.queue = []; console.log(`Hi I am ${name}`); // 创建一个微任务，在同步代码执行完后开始处理任务队列 queueMicrotask(() =\u0026gt; { this.next(); }) } eat(food) { this.queue.push(() =\u0026gt; { console.log(`I am eating ${food}`); this.next(); }); // 返回 this，实现链式调用 return this; } sleep(time) { this.queue.push(() =\u0026gt; { setTimeout(() =\u0026gt; { console.log(`等待了${time}秒...`); // 在定时结束后开始执行下一个任务 this.next(); }, time * 1000); }); return this; } sleepFirst(time) { // 插入到队列的最前面 this.queue.unshift(() =\u0026gt; { setTimeout(() =\u0026gt; { console.log(`等待了${time}秒...`); this.next(); }, time * 1000); }); return this; } next() { this.queue.shift()?.(); } } function LazyMan(name) { return new Man(name); } ","permalink":"https://findmio.github.io/post/interview/lazyman/","summary":"题目 实现一个 LazyMan，可以按照以下方式调用:\nLazyMan(\u0026#39;Tony\u0026#39;); // Hi I am Tony LazyMan(\u0026#39;Tony\u0026#39;).sleep(10).eat(\u0026#39;lunch\u0026#39;); // Hi I am Tony // 等待了10秒... // I am eating lunch LazyMan(\u0026#39;Tony\u0026#39;).eat(\u0026#39;lunch\u0026#39;).sleep(10).eat(\u0026#39;dinner\u0026#39;); // Hi I am Tony // I am eating lunch // 等待了10秒... // I am eating diner LazyMan(\u0026#39;Tony\u0026#39;) .eat(\u0026#39;lunch\u0026#39;) .eat(\u0026#39;dinner\u0026#39;) .sleepFirst(5) .sleep(10) .eat(\u0026#39;junk food\u0026#39;); // Hi I am Tony // 等待了5秒... // I am eating lunch // I am eating dinner // 等待了10秒... // I am eating junk food 思路 总共需要实现三个函数：一个同步的 eat，两个异步的 sleep、sleepFirst。","title":"编程题：实现一个 LazyMan"},{"content":"生命不息，敲码不止\n","permalink":"https://findmio.github.io/about/","summary":"生命不息，敲码不止","title":"关于我"},{"content":"题目 地址：https://leetcode.cn/problems/fibonacci-number/\n解题 斐波那契数列的特点是由后两个数字相加得出下一个数字， 首先能想到的就是用递归来解决。\n递归的出口是\nF(0) = 0，F(1) = 1\n找到出口之后就很简单了，三下五除二就写出来：\nvar fib = function (n) { if (n \u0026lt;= 1) { return n; } function add(num) { if (num === 1 || num === 0) { return num; } else { return add(num - 1) + add(num - 2); } } return add(n); }; 愉快的提交之后，\n嚯，击败了 14% 的提交。\n优化 由于盲目的使用递归，造成了大量的重复操作，时间复杂度是 O(2^n)，指数级爆炸。\n自顶而下 为了解决这些重复的操作，使用 memoization 的思想来对已计算的数据进行缓存。\n下面来用 数组 实现一下：\nvar fib = function (n) { if (n \u0026lt;= 1) { return n; } let fibArr = [0, 1]; function add(num) { if (fibArr[num] !== undefined) { return fibArr[num]; } else { fibArr[num] = add(num - 1) + add(num - 2); return fibArr[num]; } } return add(n); }; 和之前的简单递归代码相似，不过对未缓存的斐波那契数列进行缓存，再次获取这个数列的时候就从数组中直接取，省去了大量的重复递归操作。\n简单的修改之后，再次提交，击败了 92% 的提交，还算可以。\n自底向上 上面的解法是自顶而下的求值，还有一种是自底向上的解法。\n先计算出需要求的最大值，然后从小到大进行计算。\nvar fib = function (n) { if (n \u0026lt;= 1) { return n; } let fibArr = [0, 1]; for (let index = 2; index \u0026lt;= n; index++) { fibArr[index] = fibArr[index - 1] + fibArr[index - 2]; } return fibArr[n]; }; 不需要使用到递归，或许更好理解。\n","permalink":"https://findmio.github.io/post/leetcode/209_%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/","summary":"题目 地址：https://leetcode.cn/problems/fibonacci-number/\n解题 斐波那契数列的特点是由后两个数字相加得出下一个数字， 首先能想到的就是用递归来解决。\n递归的出口是\nF(0) = 0，F(1) = 1\n找到出口之后就很简单了，三下五除二就写出来：\nvar fib = function (n) { if (n \u0026lt;= 1) { return n; } function add(num) { if (num === 1 || num === 0) { return num; } else { return add(num - 1) + add(num - 2); } } return add(n); }; 愉快的提交之后，\n嚯，击败了 14% 的提交。\n优化 由于盲目的使用递归，造成了大量的重复操作，时间复杂度是 O(2^n)，指数级爆炸。\n自顶而下 为了解决这些重复的操作，使用 memoization 的思想来对已计算的数据进行缓存。\n下面来用 数组 实现一下：","title":"209_斐波那契数"},{"content":"hugo 常用命令 新建一个页面 hugo new [path] 启动一个服务器 # 启动生产模式的预览 hugo server # 启动开发模式的预览（会显示草稿文件） hugo server -D ","permalink":"https://findmio.github.io/hugo/","summary":"hugo 常用命令 新建一个页面 hugo new [path] 启动一个服务器 # 启动生产模式的预览 hugo server # 启动开发模式的预览（会显示草稿文件） hugo server -D ","title":""}]