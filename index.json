[{"content":"在使用 js 的库 xlsx 解析 Excel 表格数据的时候，其中一个日期字段，解析之后是 45040.3964930556 这样子，在 Excel 中展示的是 2023/4/24 9:30\n这又是什么奇怪的格式，看起来也不像时间戳啊\noa date (OLE Automation date) oa date 使用浮点数来保存时间，分为两个部分，整数部分从 1899年12月30日 以来的天数，小数部分是这一天的时间除以24\njs 中的 Date 对象则是从 自 1970年1月1日 起经过的毫秒数\n如何转换 1. 使用 moment.js 库 moment 提供了一个插件 moment-msdate，参考文档\n把 moment 对象转换为 oa date\nmoment().toOADate(); // 一个浮点数 把 oa date 转换为 moment 对象\nmoment.fromOADate(41493); // Wed Aug 07 2013 00:00:00 GMT-0600 (MDT) 2. 自定义函数 把 Date 对象转换为 oa date\nfunction JSDateToOADate(date: Date) { return (date.getTime() / (86400 * 1000)) + 25569; } 把 oa date 转换为 Date\nfunction OADateToJSDate(date: number) { return new Date((date - 25569) * 86400 * 1000); } 其中的 1000 是秒到毫秒之间的换算倍数\n86400 是 一天之中的总秒数 24 * 60 * 60\n25569 则是 1899年12月30日 到 1970年1月1日 间隔的天数\n","permalink":"https://findmio.github.io/post/skills/oadate/","summary":"在使用 js 的库 xlsx 解析 Excel 表格数据的时候，其中一个日期字段，解析之后是 45040.3964930556 这样子，在 Excel 中展示的是 2023/4/24 9:30\n这又是什么奇怪的格式，看起来也不像时间戳啊\noa date (OLE Automation date) oa date 使用浮点数来保存时间，分为两个部分，整数部分从 1899年12月30日 以来的天数，小数部分是这一天的时间除以24\njs 中的 Date 对象则是从 自 1970年1月1日 起经过的毫秒数\n如何转换 1. 使用 moment.js 库 moment 提供了一个插件 moment-msdate，参考文档\n把 moment 对象转换为 oa date\nmoment().toOADate(); // 一个浮点数 把 oa date 转换为 moment 对象\nmoment.fromOADate(41493); // Wed Aug 07 2013 00:00:00 GMT-0600 (MDT) 2. 自定义函数 把 Date 对象转换为 oa date\nfunction JSDateToOADate(date: Date) { return (date.","title":"oa date 是什么"},{"content":"为了获取生产环境报错对应的源码位置，之前将打包之后的 map 文件上传到 node 服务，日积月累之下，已经占用了好几个 g 的磁盘空间\n就想到用 LRU 算法 的思想去对这些文件进行管理\nLRU LRU 英文全称是 Least Recently Used，最不经常使用，是一种内存管理算法。可以参考 leetcode 的描述 LRU缓存机制\n核心思想是 “如果数据最近被访问过,那么将来被访问的几率也更高”。所以在容量有限的情况下，淘汰最近最少使用的缓存。即近期内最不会被访问的数据进行淘汰\n可以使用一个队列来缓存数据\n如果有新数据插入，就移出队列中最后一个缓存\n如果有数据访问，要将访问到的数据移到尾部，重新进行排序\n实现 在 javascript 中，可以使用 Map 或者 Set 来模拟一个队列\nimport path from \u0026#34;path\u0026#34;; import fse from \u0026#34;fs-extra\u0026#34;; /** 上传 sourcemap 存放地址 */ export const sourcemapFilePath = path.join(__dirname, \u0026#34;../../../../uploads\u0026#34;); // 使用 LRU 算法去控制 sourcemap 文件 export class SourcemapCache { private path = path.join(__dirname, \u0026#34;cache.json\u0026#34;); private length: number; // 最大缓存数量 private cache: Set\u0026lt;string\u0026gt;; constructor(length = 10) { this.length = length; this.cache = new Set(this.readCache() || []); } private readCache = () =\u0026gt; { try { return fse.readJSONSync(this.path); } catch (error) { return; } }; private saveCache(date: string[]) { fse.ensureFile(this.path).then(() =\u0026gt; { fse.writeJSONSync(this.path, date); }); } private delete(key: string) { fse.remove(path.resolve(sourcemapFilePath, key)); } // 访问 缓存中的某一项 access(key: string) { if (this.cache.has(key)) { this.cache.delete(key); this.cache.add(key); this.saveCache([...this.cache.keys()]); } } // 数据插入，重新排序 put(key: string) { const keys = [...this.cache.keys()]; // 已存在队列，则移到尾部 if (this.cache.has(key)) { this.access(key); } else { if (keys.length \u0026gt;= this.length) { const oldestKey = keys[0]; this.cache.delete(oldestKey); this.delete(oldestKey); } this.cache.add(key); this.saveCache([...this.cache.keys()]); } } } ","permalink":"https://findmio.github.io/post/skills/%E4%BD%BF%E7%94%A8lru%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4/","summary":"为了获取生产环境报错对应的源码位置，之前将打包之后的 map 文件上传到 node 服务，日积月累之下，已经占用了好几个 g 的磁盘空间\n就想到用 LRU 算法 的思想去对这些文件进行管理\nLRU LRU 英文全称是 Least Recently Used，最不经常使用，是一种内存管理算法。可以参考 leetcode 的描述 LRU缓存机制\n核心思想是 “如果数据最近被访问过,那么将来被访问的几率也更高”。所以在容量有限的情况下，淘汰最近最少使用的缓存。即近期内最不会被访问的数据进行淘汰\n可以使用一个队列来缓存数据\n如果有新数据插入，就移出队列中最后一个缓存\n如果有数据访问，要将访问到的数据移到尾部，重新进行排序\n实现 在 javascript 中，可以使用 Map 或者 Set 来模拟一个队列\nimport path from \u0026#34;path\u0026#34;; import fse from \u0026#34;fs-extra\u0026#34;; /** 上传 sourcemap 存放地址 */ export const sourcemapFilePath = path.join(__dirname, \u0026#34;../../../../uploads\u0026#34;); // 使用 LRU 算法去控制 sourcemap 文件 export class SourcemapCache { private path = path.join(__dirname, \u0026#34;cache.json\u0026#34;); private length: number; // 最大缓存数量 private cache: Set\u0026lt;string\u0026gt;; constructor(length = 10) { this.","title":"使用LRU算法优化服务器存储空间"},{"content":"const obj = { foo: { bar: { foo: { bar: \u0026#39;https://findmio.github.io/post/skills/在nodejs中深度打印对象/\u0026#39;, foo: undefined } } } }; 如何在 nodejs 中打印这样一个对象？\n直接使用 console.log 会有什么问题\n{ foo: { bar: { foo: [Object] } } } 对象的嵌套层级超过三层，就会显示为 Object\n那么该如何完整的打印出这个对象呢？\n方法一：JSON.stringify() 众所周知，此方法是将 JavaScript 对象或值转换为 JSON 字符串，直接调用的返回值可读性不是很好\nconsole.log(JSON.stringify(obj)); 可以使用 第三个参数 space （缩进用的空白字符串，如果为数字，则代表有多少个空格），来进行美化\nconsole.log(JSON.stringify(obj, null, 2)); 缺点：\n没有对输出结果的值高亮 JSON.stringify() 会对一些属性进行处理，比如忽略掉 undefined 、函数以及 symbol 值 方法二：console.dir() 和 util.inspect 这两个函数的参数是一样的，比较常用的有，查看完整参数\nshowHidden ：如果为 true，则格式化结果中会显示隐藏的不可枚举的符号和属性。默认为 false depth：格式化对象时进行递归的次数，如果要使其无限递归，可传入 null 或者 Infinity。默认为 2 colors：如果为 true，输出带 ANSI 颜色的代码。默认为 false // 需要导入 nodejs 核心模块 util console.log(util.inspect(obj, { depth: null, colors: true })); console.dir(obj, { depth: null, colors: true }); 参考链接： https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify\nhttps://nodejs.org/api/util.html#utilinspectobject-options\n","permalink":"https://findmio.github.io/post/skills/%E5%9C%A8nodejs%E4%B8%AD%E6%B7%B1%E5%BA%A6%E6%89%93%E5%8D%B0%E5%AF%B9%E8%B1%A1/","summary":"const obj = { foo: { bar: { foo: { bar: \u0026#39;https://findmio.github.io/post/skills/在nodejs中深度打印对象/\u0026#39;, foo: undefined } } } }; 如何在 nodejs 中打印这样一个对象？\n直接使用 console.log 会有什么问题\n{ foo: { bar: { foo: [Object] } } } 对象的嵌套层级超过三层，就会显示为 Object\n那么该如何完整的打印出这个对象呢？\n方法一：JSON.stringify() 众所周知，此方法是将 JavaScript 对象或值转换为 JSON 字符串，直接调用的返回值可读性不是很好\nconsole.log(JSON.stringify(obj)); 可以使用 第三个参数 space （缩进用的空白字符串，如果为数字，则代表有多少个空格），来进行美化\nconsole.log(JSON.stringify(obj, null, 2)); 缺点：\n没有对输出结果的值高亮 JSON.stringify() 会对一些属性进行处理，比如忽略掉 undefined 、函数以及 symbol 值 方法二：console.dir() 和 util.inspect 这两个函数的参数是一样的，比较常用的有，查看完整参数\nshowHidden ：如果为 true，则格式化结果中会显示隐藏的不可枚举的符号和属性。默认为 false depth：格式化对象时进行递归的次数，如果要使其无限递归，可传入 null 或者 Infinity。默认为 2 colors：如果为 true，输出带 ANSI 颜色的代码。默认为 false // 需要导入 nodejs 核心模块 util console.","title":"在nodejs中深度打印对象"},{"content":"题目 地址：https://leetcode.cn/problems/two-sum/\n思路 通过 Map 把数组的每一项进行缓存 （key 为数组中的项，value 为索引），然后再对数组进行遍历，并计算是否存在 key 相加等于目标值\n遍历数组，判断差值是否存在 Map 中 如果存在，返回对应的索引 如果不存在，将这一项添加到 Map 中 数组遍历结束，返回一个兜底的数组 [-1, -1] /** * @param {number[]} nums * @param {number} target * @return {number[]} */ var twoSum = function (nums, target) { const map = new Map(); for (let i = 0; i \u0026lt; nums.length; i++) { const item = nums[i]; const different = target - item; if (map.get(different) !== undefined) { return [map.get(different), i]; } else { map.set(item, i); } } return [-1, -1]; }; ","permalink":"https://findmio.github.io/post/leetcode/1_%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","summary":"题目 地址：https://leetcode.cn/problems/two-sum/\n思路 通过 Map 把数组的每一项进行缓存 （key 为数组中的项，value 为索引），然后再对数组进行遍历，并计算是否存在 key 相加等于目标值\n遍历数组，判断差值是否存在 Map 中 如果存在，返回对应的索引 如果不存在，将这一项添加到 Map 中 数组遍历结束，返回一个兜底的数组 [-1, -1] /** * @param {number[]} nums * @param {number} target * @return {number[]} */ var twoSum = function (nums, target) { const map = new Map(); for (let i = 0; i \u0026lt; nums.length; i++) { const item = nums[i]; const different = target - item; if (map.get(different) !== undefined) { return [map.","title":"1_两数之和"},{"content":"树 树 是数据结构中很常见的一种数据结构，是一种分层数据的抽象模型。\n树形结构存在下列特征：\n除根节点外，每个节点都有一个父节点 每个节点有零个或者多个子节点 二叉树 二叉树 是树形结构中的一种。 二叉树中的节点最多只能有两个子节点：一个是左节点，一个是右节点。\n二叉搜索树（BST）是二叉树的一种，但是只允许你在左节点存储（比父节点）小的值， 在右节点存储（比父节点）大的值。\n实现一个二叉搜索树\n构造一个节点的类用来存储节点值和左右节点 构造一个二叉搜索树的类，它有一个根节点 实现插入节点的方法（insert）\n根据插入的值创建一个节点 判断是否存在根节点 不存在根节点：直接将根节点指向此节点 存在根节点：将根节点和此节点传入 insertNode 方法去处理插入的位置 实现判断插入节点位置的方法（insertNode）。第一个参数为父节点，第二个参数为子节点\n判断子节点要插入到父节点的左侧还是右侧：比父节点小的插入到父节点左侧，比父节点大的插入到父节点右侧 找到子节点要插入到父节点的位置，判断该位置是否已存在 如果被插入的位置已存在的，则递归调用 insertNode 方法，将父节点替换为被插入位置的节点 如果被插入的位置不存在的，直接将子节点插入到父节点上 class Node { // {1} constructor(value) { this.val = value; // 节点值 this.left = null; // 左节点 this.right = null; // 右节点 } } class BinarySearchTree { // {2} constructor() { this.root = null; // 根节点 } insert(value) { const node = new Node(value); // {3} if (this.root === null) { // {4} this.root = node; // {5} } else { this.insertNode(this.root, node); // {6} } } insertNode(root, node) { if (node.val \u0026gt; root.val) { // {7} if (root.right !== null) { // {8} this.insertNode(root.right, node); // {9} } else { root.right = node; // {10} } } else { if (root.left !== null) { // {8} this.insertNode(root.left, node); // {9} } else { root.left = node; // {10} } } } } ","permalink":"https://findmio.github.io/post/tree/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/","summary":"树 树 是数据结构中很常见的一种数据结构，是一种分层数据的抽象模型。\n树形结构存在下列特征：\n除根节点外，每个节点都有一个父节点 每个节点有零个或者多个子节点 二叉树 二叉树 是树形结构中的一种。 二叉树中的节点最多只能有两个子节点：一个是左节点，一个是右节点。\n二叉搜索树（BST）是二叉树的一种，但是只允许你在左节点存储（比父节点）小的值， 在右节点存储（比父节点）大的值。\n实现一个二叉搜索树\n构造一个节点的类用来存储节点值和左右节点 构造一个二叉搜索树的类，它有一个根节点 实现插入节点的方法（insert）\n根据插入的值创建一个节点 判断是否存在根节点 不存在根节点：直接将根节点指向此节点 存在根节点：将根节点和此节点传入 insertNode 方法去处理插入的位置 实现判断插入节点位置的方法（insertNode）。第一个参数为父节点，第二个参数为子节点\n判断子节点要插入到父节点的左侧还是右侧：比父节点小的插入到父节点左侧，比父节点大的插入到父节点右侧 找到子节点要插入到父节点的位置，判断该位置是否已存在 如果被插入的位置已存在的，则递归调用 insertNode 方法，将父节点替换为被插入位置的节点 如果被插入的位置不存在的，直接将子节点插入到父节点上 class Node { // {1} constructor(value) { this.val = value; // 节点值 this.left = null; // 左节点 this.right = null; // 右节点 } } class BinarySearchTree { // {2} constructor() { this.root = null; // 根节点 } insert(value) { const node = new Node(value); // {3} if (this.","title":"树和二叉树"},{"content":"题目 实现一个 LazyMan，可以按照以下方式调用:\nLazyMan(\u0026#39;Tony\u0026#39;); // Hi I am Tony LazyMan(\u0026#39;Tony\u0026#39;).sleep(10).eat(\u0026#39;lunch\u0026#39;); // Hi I am Tony // 等待了10秒... // I am eating lunch LazyMan(\u0026#39;Tony\u0026#39;).eat(\u0026#39;lunch\u0026#39;).sleep(10).eat(\u0026#39;dinner\u0026#39;); // Hi I am Tony // I am eating lunch // 等待了10秒... // I am eating diner LazyMan(\u0026#39;Tony\u0026#39;) .eat(\u0026#39;lunch\u0026#39;) .eat(\u0026#39;dinner\u0026#39;) .sleepFirst(5) .sleep(10) .eat(\u0026#39;junk food\u0026#39;); // Hi I am Tony // 等待了5秒... // I am eating lunch // I am eating dinner // 等待了10秒... // I am eating junk food 思路 总共需要实现三个函数：一个同步的 eat，两个异步的 sleep、sleepFirst。\n目前可公开情报：\n这些函数需要能够 链式调用，所以在执行完毕，要返回这个对象 异步函数会延迟之后的函数执行 sleepFirst 需要先执行 为了实现异步函数阻塞之后的函数执行，我们先用一个队列来储存函数的调用，然后依序执行。\nclass Man { constructor(name) { this.queue = []; console.log(`Hi I am ${name}`); // 创建一个微任务，在同步代码执行完后开始处理任务队列 queueMicrotask(() =\u0026gt; { this.next(); }) } eat(food) { this.queue.push(() =\u0026gt; { console.log(`I am eating ${food}`); this.next(); }); // 返回 this，实现链式调用 return this; } sleep(time) { this.queue.push(() =\u0026gt; { setTimeout(() =\u0026gt; { console.log(`等待了${time}秒...`); // 在定时结束后开始执行下一个任务 this.next(); }, time * 1000); }); return this; } sleepFirst(time) { // 插入到队列的最前面 this.queue.unshift(() =\u0026gt; { setTimeout(() =\u0026gt; { console.log(`等待了${time}秒...`); this.next(); }, time * 1000); }); return this; } next() { this.queue.shift()?.(); } } function LazyMan(name) { return new Man(name); } ","permalink":"https://findmio.github.io/post/interview/lazyman/","summary":"题目 实现一个 LazyMan，可以按照以下方式调用:\nLazyMan(\u0026#39;Tony\u0026#39;); // Hi I am Tony LazyMan(\u0026#39;Tony\u0026#39;).sleep(10).eat(\u0026#39;lunch\u0026#39;); // Hi I am Tony // 等待了10秒... // I am eating lunch LazyMan(\u0026#39;Tony\u0026#39;).eat(\u0026#39;lunch\u0026#39;).sleep(10).eat(\u0026#39;dinner\u0026#39;); // Hi I am Tony // I am eating lunch // 等待了10秒... // I am eating diner LazyMan(\u0026#39;Tony\u0026#39;) .eat(\u0026#39;lunch\u0026#39;) .eat(\u0026#39;dinner\u0026#39;) .sleepFirst(5) .sleep(10) .eat(\u0026#39;junk food\u0026#39;); // Hi I am Tony // 等待了5秒... // I am eating lunch // I am eating dinner // 等待了10秒... // I am eating junk food 思路 总共需要实现三个函数：一个同步的 eat，两个异步的 sleep、sleepFirst。","title":"编程题：实现一个 LazyMan"},{"content":"生命不息，敲码不止\n","permalink":"https://findmio.github.io/about/","summary":"生命不息，敲码不止","title":"关于我"},{"content":"题目 地址：https://leetcode.cn/problems/fibonacci-number/\n解题 斐波那契数列的特点是由后两个数字相加得出下一个数字， 首先能想到的就是用递归来解决。\n递归的出口是\nF(0) = 0，F(1) = 1\n找到出口之后就很简单了，三下五除二就写出来：\nvar fib = function (n) { if (n \u0026lt;= 1) { return n; } function add(num) { if (num === 1 || num === 0) { return num; } else { return add(num - 1) + add(num - 2); } } return add(n); }; 愉快的提交之后，\n嚯，击败了 14% 的提交。\n优化 由于盲目的使用递归，造成了大量的重复操作，时间复杂度是 O(2^n)，指数级爆炸。\n自顶而下 为了解决这些重复的操作，使用 memoization 的思想来对已计算的数据进行缓存。\n下面来用 数组 实现一下：\nvar fib = function (n) { if (n \u0026lt;= 1) { return n; } let fibArr = [0, 1]; function add(num) { if (fibArr[num] !== undefined) { return fibArr[num]; } else { fibArr[num] = add(num - 1) + add(num - 2); return fibArr[num]; } } return add(n); }; 和之前的简单递归代码相似，不过对未缓存的斐波那契数列进行缓存，再次获取这个数列的时候就从数组中直接取，省去了大量的重复递归操作。\n简单的修改之后，再次提交，击败了 92% 的提交，还算可以。\n自底向上 上面的解法是自顶而下的求值，还有一种是自底向上的解法。\n先计算出需要求的最大值，然后从小到大进行计算。\nvar fib = function (n) { if (n \u0026lt;= 1) { return n; } let fibArr = [0, 1]; for (let index = 2; index \u0026lt;= n; index++) { fibArr[index] = fibArr[index - 1] + fibArr[index - 2]; } return fibArr[n]; }; 不需要使用到递归，或许更好理解。\n","permalink":"https://findmio.github.io/post/leetcode/209_%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/","summary":"题目 地址：https://leetcode.cn/problems/fibonacci-number/\n解题 斐波那契数列的特点是由后两个数字相加得出下一个数字， 首先能想到的就是用递归来解决。\n递归的出口是\nF(0) = 0，F(1) = 1\n找到出口之后就很简单了，三下五除二就写出来：\nvar fib = function (n) { if (n \u0026lt;= 1) { return n; } function add(num) { if (num === 1 || num === 0) { return num; } else { return add(num - 1) + add(num - 2); } } return add(n); }; 愉快的提交之后，\n嚯，击败了 14% 的提交。\n优化 由于盲目的使用递归，造成了大量的重复操作，时间复杂度是 O(2^n)，指数级爆炸。\n自顶而下 为了解决这些重复的操作，使用 memoization 的思想来对已计算的数据进行缓存。\n下面来用 数组 实现一下：","title":"209_斐波那契数"},{"content":"hugo 常用命令 新建一个页面 hugo new [path] 启动一个服务器 # 启动生产模式的预览 hugo server # 启动开发模式的预览（会显示草稿文件） hugo server -D ","permalink":"https://findmio.github.io/hugo/","summary":"hugo 常用命令 新建一个页面 hugo new [path] 启动一个服务器 # 启动生产模式的预览 hugo server # 启动开发模式的预览（会显示草稿文件） hugo server -D ","title":""}]