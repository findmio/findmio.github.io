<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>MIO&#39;S BLOG</title>
    <link>https://findmio.github.io/</link>
    <description>Recent content on MIO&#39;S BLOG</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Fri, 25 Nov 2022 10:30:15 +0800</lastBuildDate><atom:link href="https://findmio.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>在nodejs中深度打印对象</title>
      <link>https://findmio.github.io/post/skills/%E5%9C%A8nodejs%E4%B8%AD%E6%B7%B1%E5%BA%A6%E6%89%93%E5%8D%B0%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Fri, 25 Nov 2022 10:30:15 +0800</pubDate>
      
      <guid>https://findmio.github.io/post/skills/%E5%9C%A8nodejs%E4%B8%AD%E6%B7%B1%E5%BA%A6%E6%89%93%E5%8D%B0%E5%AF%B9%E8%B1%A1/</guid>
      <description>const obj = { foo: { bar: { foo: { bar: &amp;#39;https://findmio.github.io/post/skills/在nodejs中深度打印对象/&amp;#39;, foo: undefined } } } }; 如何在 nodejs 中打印这样一个对象？
直接使用 console.log 会有什么问题
{ foo: { bar: { foo: [Object] } } } 对象的嵌套层级超过三层，就会显示为 Object
那么该如何完整的打印出这个对象呢？
方法一：JSON.stringify() 众所周知，此方法是将 JavaScript 对象或值转换为 JSON 字符串，直接调用的返回值可读性不是很好
console.log(JSON.stringify(obj)); 可以使用 第三个参数 space （缩进用的空白字符串，如果为数字，则代表有多少个空格），来进行美化
console.log(JSON.stringify(obj, null, 2)); 缺点：
没有对输出结果的值高亮 JSON.stringify() 会对一些属性进行处理，比如忽略掉 undefined 、函数以及 symbol 值 方法二：console.dir() 和 util.inspect 这两个函数的参数是一样的，比较常用的有，查看完整参数
showHidden ：如果为 true，则格式化结果中会显示隐藏的不可枚举的符号和属性。默认为 false depth：格式化对象时进行递归的次数，如果要使其无限递归，可传入 null 或者 Infinity。默认为 2 colors：如果为 true，输出带 ANSI 颜色的代码。默认为 false // 需要导入 nodejs 核心模块 util console.</description>
    </item>
    
    <item>
      <title>1_两数之和</title>
      <link>https://findmio.github.io/post/leetcode/1_%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Tue, 21 Jun 2022 23:27:41 +0800</pubDate>
      
      <guid>https://findmio.github.io/post/leetcode/1_%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</guid>
      <description>题目 地址：https://leetcode.cn/problems/two-sum/
思路 通过 Map 把数组的每一项进行缓存 （key 为数组中的项，value 为索引），然后再对数组进行遍历，并计算是否存在 key 相加等于目标值
遍历数组，判断差值是否存在 Map 中 如果存在，返回对应的索引 如果不存在，将这一项添加到 Map 中 数组遍历结束，返回一个兜底的数组 [-1, -1] /** * @param {number[]} nums * @param {number} target * @return {number[]} */ var twoSum = function (nums, target) { const map = new Map(); for (let i = 0; i &amp;lt; nums.length; i++) { const item = nums[i]; const different = target - item; if (map.get(different) !== undefined) { return [map.</description>
    </item>
    
    <item>
      <title>树和二叉树</title>
      <link>https://findmio.github.io/post/tree/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Thu, 09 Jun 2022 23:49:17 +0800</pubDate>
      
      <guid>https://findmio.github.io/post/tree/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>树 树 是数据结构中很常见的一种数据结构，是一种分层数据的抽象模型。
树形结构存在下列特征：
除根节点外，每个节点都有一个父节点 每个节点有零个或者多个子节点 二叉树 二叉树 是树形结构中的一种。 二叉树中的节点最多只能有两个子节点：一个是左节点，一个是右节点。
二叉搜索树（BST）是二叉树的一种，但是只允许你在左节点存储（比父节点）小的值， 在右节点存储（比父节点）大的值。
实现一个二叉搜索树
构造一个节点的类用来存储节点值和左右节点 构造一个二叉搜索树的类，它有一个根节点 实现插入节点的方法（insert）
根据插入的值创建一个节点 判断是否存在根节点 不存在根节点：直接将根节点指向此节点 存在根节点：将根节点和此节点传入 insertNode 方法去处理插入的位置 实现判断插入节点位置的方法（insertNode）。第一个参数为父节点，第二个参数为子节点
判断子节点要插入到父节点的左侧还是右侧：比父节点小的插入到父节点左侧，比父节点大的插入到父节点右侧 找到子节点要插入到父节点的位置，判断该位置是否已存在 如果被插入的位置已存在的，则递归调用 insertNode 方法，将父节点替换为被插入位置的节点 如果被插入的位置不存在的，直接将子节点插入到父节点上 class Node { // {1} constructor(value) { this.val = value; // 节点值 this.left = null; // 左节点 this.right = null; // 右节点 } } class BinarySearchTree { // {2} constructor() { this.root = null; // 根节点 } insert(value) { const node = new Node(value); // {3} if (this.</description>
    </item>
    
    <item>
      <title>编程题：实现一个 LazyMan</title>
      <link>https://findmio.github.io/post/interview/lazyman/</link>
      <pubDate>Mon, 30 May 2022 22:16:59 +0800</pubDate>
      
      <guid>https://findmio.github.io/post/interview/lazyman/</guid>
      <description>题目 实现一个 LazyMan，可以按照以下方式调用:
LazyMan(&amp;#39;Tony&amp;#39;); // Hi I am Tony LazyMan(&amp;#39;Tony&amp;#39;).sleep(10).eat(&amp;#39;lunch&amp;#39;); // Hi I am Tony // 等待了10秒... // I am eating lunch LazyMan(&amp;#39;Tony&amp;#39;).eat(&amp;#39;lunch&amp;#39;).sleep(10).eat(&amp;#39;dinner&amp;#39;); // Hi I am Tony // I am eating lunch // 等待了10秒... // I am eating diner LazyMan(&amp;#39;Tony&amp;#39;) .eat(&amp;#39;lunch&amp;#39;) .eat(&amp;#39;dinner&amp;#39;) .sleepFirst(5) .sleep(10) .eat(&amp;#39;junk food&amp;#39;); // Hi I am Tony // 等待了5秒... // I am eating lunch // I am eating dinner // 等待了10秒... // I am eating junk food 思路 总共需要实现三个函数：一个同步的 eat，两个异步的 sleep、sleepFirst。</description>
    </item>
    
    <item>
      <title>关于我</title>
      <link>https://findmio.github.io/about/</link>
      <pubDate>Mon, 23 May 2022 20:04:28 +0800</pubDate>
      
      <guid>https://findmio.github.io/about/</guid>
      <description>爱学习，爱生活</description>
    </item>
    
    <item>
      <title>209_斐波那契数</title>
      <link>https://findmio.github.io/post/leetcode/209_%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/</link>
      <pubDate>Mon, 23 May 2022 20:03:58 +0800</pubDate>
      
      <guid>https://findmio.github.io/post/leetcode/209_%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/</guid>
      <description>题目 地址：https://leetcode.cn/problems/fibonacci-number/
解题 斐波那契数列的特点是由后两个数字相加得出下一个数字， 首先能想到的就是用递归来解决。
递归的出口是
F(0) = 0，F(1) = 1
找到出口之后就很简单了，三下五除二就写出来：
var fib = function (n) { if (n &amp;lt;= 1) { return n; } function add(num) { if (num === 1 || num === 0) { return num; } else { return add(num - 1) + add(num - 2); } } return add(n); }; 愉快的提交之后，
嚯，击败了 14% 的提交。
优化 由于盲目的使用递归，造成了大量的重复操作，时间复杂度是 O(2^n)，指数级爆炸。
自顶而下 为了解决这些重复的操作，使用 memoization 的思想来对已计算的数据进行缓存。
下面来用 数组 实现一下：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://findmio.github.io/hugo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://findmio.github.io/hugo/</guid>
      <description>hugo 常用命令 新建一个页面 hugo new [path] 启动一个服务器 # 启动生产模式的预览 hugo server # 启动开发模式的预览（会显示草稿文件） hugo server -D </description>
    </item>
    
    
    
  </channel>
</rss>
